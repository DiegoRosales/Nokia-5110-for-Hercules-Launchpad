/*******************************************************
 * Nokia 5110 library of basic functions for the Cortex R Family,
 * more specifically for the Hercules Launchpad
 *
 * Version 1.01
 *
 * By: Diego Rosales
 * inspired by several codes such as Jim Lindblom's and Julian Ilett's codes
 *
 * Created on January 26 / 2014
 * Last edited on February 1 / 2014
 *
 * Recent changes: Added "recent changes" category,
 * added the rtiNotification function so that this is the only file
 * you need to use, added setBackLight
 *
 * License: FREE FOR ALL!! just don't use it to destroy the world
 *
 * The order of the pins can be anyone, as it does not use
 * any hardware SPI interface, but a software one instead
 * to change the pins, just change the definitions in NokiaLib.h
 *
 * Note that this code assumes that the basic components
 * are created by HALcoGen, such as "het.h" and "gio.h".
 * This code also assumes one RTI counter with enabled interrupts
 * for more info go to www.produccionyelectronica.blogspot.com
 *
 * THIS IS WORK IN PROGRSS! DO NOT ASSUME EVERYTHING WILL WORK
 * BECAUSE IT MAY OR MAY NOT WORK
 *******************************************************/

#include "NokiaLib.h"

// Variable affected by the interrupts
bool rtiBreak = false;

// Display buffer variable
volatile byte displayBuffer[xLength*yLength];

void displayInit(void)
{
	// Sets up the environment
	_enable_IRQ(); // This enables interrupts
	rtiEnableNotification(rtiNOTIFICATION_COMPARE0); // This enables the Real Time Interrupt notification

	// Powers up the display
	gioSetBit(hetPORT1, VCCPIN, 1);

	// Resets the display
	resetDisplay();

	// Initialization commands
	writeData(0x21, commandData); // Extended instruction set control
	writeData(0xB8, commandData); //Set LCD Vop (Contrast)
	writeData(0x04, commandData); //Set Temp coefficent
	writeData(0x14, commandData); //LCD bias mode 1:48 (try 0x13)
	//We must send 0x20 before modifying the display control mode
	writeData(0x20, commandData);
	writeData(0x0C, commandData); //Set display control, normal mode.

	// Clears the display buffer variable
	clearBuffer(WHITE);
}

// Function that writes data to the display
void writeData(byte data, bool d_c)
{
	if(d_c) // display Data
		gioSetBit(hetPORT1, DCPIN, 1);
	else // command data
		gioSetBit(hetPORT1, DCPIN, 0);

	gioSetBit(hetPORT1, CEPIN, 0); // CE = 1 -> 0 (active low)
	int i;
	for(i = 7; i>=0; i--) // Sends blocks of 8 bits
	{
		gioSetBit(hetPORT1, CLKPIN, 0); // CLK = 1 -> 0
		gioSetBit(hetPORT1, DINPIN, BIT(data, i)); // set bit 'i'
		ckDelay(); // Waits half CK period
		gioSetBit(hetPORT1, CLKPIN, 1); // CK = 0 -> 1
		ckDelay(); // Waits the other half CK period
	}

	// CE = 0 -> 1
	gioSetBit(hetPORT1, CEPIN, 1);
}

// Sets an all white or an all black display
void clearDisplay(bool BlackWhite)
{
	int i;
	byte clrData;
	if(BlackWhite) // If it's white, all pixels are 0
		clrData = 0x00;
	else // If it's white, all pixels are 1
		clrData = 0xFF;

	for(i = 0; i < xLength*yLength; i++)
		writeData(clrData, displayData);
}

// Sends a reset signal to the display
void resetDisplay(void)
{
	gioSetBit(hetPORT1, RSTPIN, 0);
	ckDelay();
	gioSetBit(hetPORT1, RSTPIN, 1);
}

// Function that sets the brightness of the
// backlight LEDs
void setBacklight(unsigned int intensity)
{
	if(intensity > 100)
		intensity = 100;

	pwmSetDuty(hetRAM1, pwm0, 100-intensity);
}

// Delay for half a clock cycle (0.001ms)
void ckDelay(void)
{
	rtiStartCounter(rtiCOUNTER_BLOCK0);
	while(!rtiBreak);
	rtiBreak = false;
}

void setCursor(byte x, byte y)
{
	// Double check if the address is in range
	if(x > xLength)
		x = xLength;

	if(y > yLength)
		y = yLength;
	byte xAddress = x + 128; // Sets the format 0b1xxxxxx
	byte yAddress = y + 64; // Sets the format 0b01000yyy
	writeData(xAddress, commandData);
	writeData(yAddress, commandData);
}

// Sets the column only
void setColumn(byte y)
{
	// Double check if the address is in range
	if(y > yLength)
		y = yLength;

	byte yAddress = y + 64; // Sets the format 0b01000yyy
	writeData(yAddress, commandData);
}

// Sets the line only
void setLine(byte x)
{
	// Double check if the address is in range
	if(x > xLength)
		x = xLength;

	byte xAddress = x + 128; // Sets the format 0b1xxxxxx
	writeData(xAddress, commandData);
}

// Function that clears the buffer with
// a white or black pattern
void clearBuffer(bool BlackWhite)
{
	int i;
	byte template;
	if(BlackWhite)
		template = 0x00; // White pattern
	else
		template = 0xFF; // Black pattern

	for (i = 0; i < xLength*yLength; i++)
		displayBuffer[i] = template;
}

// Function that sends the buffer
// to the display
void sendBuffer(void)
{
	int i;
	for (i = 0; i<xLength*yLength; i++)
		writeData(displayBuffer[i], displayData);
}

// Function that sets a byte to a specific location
void bufferSetByte(byte x, byte y, byte Data)
{
	// Double check if the address is in range
	if(x > xLength)
		x = xLength;

	if(y > yLength)
		y = yLength;

	displayBuffer[x + y*xLength] = Data;
}

void bufferSetBit(byte x, byte y, bool BlackWhite)
{
	// Double check if the address is in range
	if(x > xLength)
		x = xLength;

	if(y > yLength*8)
		y = yLength*8;

	int coord = x + (y/8)*xLength;
	byte bit = y%8;
	byte numero = (1 << bit);
	if(!BlackWhite) // If it's black...
		displayBuffer[coord] = displayBuffer[coord] | numero;
	else // If it's white...
		displayBuffer[coord] = displayBuffer[coord] & ~numero;
}
// This function is a copy of the function located
// in notification.c and takes care of the
// RTI interrupts
void rtiNotification(uint32 notification)
{
/*  enter user code between the USER CODE BEGIN and USER CODE END. */
/* USER CODE BEGIN (9) */
//	extern bool rtiBreak;
	if(notification == rtiNOTIFICATION_COMPARE0)
	{
		rtiStopCounter(rtiCOUNTER_BLOCK0);
		rtiBreak = true;
	}
/* USER CODE END */
}

// Demo 1: Sparkfun logo
void demo(void)
{
	byte demoMap[xLength*yLength] = {
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 bytes cover an 8x12 block in the left corner of the display
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
			  0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
			  0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
			  0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
			  0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
			  0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
			  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
			  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
			  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
			  0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
			  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
			  0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
			  0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
			  0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
			};

	// Sends each byte
	int i = 0;
	for (i = 0; i< xLength*yLength; i++)
		writeData(demoMap[i], displayData);
}

// Demo 2: Surprise!
void demo2(void)
{
	byte demoMap[xLength*yLength] = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xF0, 0xC0, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF0, 0xC0,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xF9, 0xF1, 0xC1, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x81,
			0xC1, 0xE1, 0xF1, 0xFD, 0xFF, 0xFF, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0,
			0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8,
			0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
			0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0E, 0x08, 0x0C,
			0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
			0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
				};

	// Sends each byte
	int i = 0;
	for (i = 0; i< xLength*yLength; i++)
		writeData(demoMap[i], displayData);
}
